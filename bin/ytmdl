#!/usr/bin/env python3
"""
    * ytmdl.py - A script to download songs.

----------------------------------------------------
     A simple script to download songs in mp3 format
     from Youtube.
     Users pass the song name as arguments.
----------------------------------------------------
    --> Deepjyoti Barman
    --> deepjyoti30@github.com
"""

from __future__ import unicode_literals
from typing import Union

from colorama import init
from colorama import Fore, Style
import argparse
from xdg.BaseDirectory import xdg_cache_home
from os import path
from simber import Logger
from youtube_dl.utils import ExtractorError
from ytmdl import (
            dir,
            song,
            yt,
            defaults,
            prepend,
            setupConfig,
            cache,
            utility,
            metadata,
            manual,
            stringutils,
)
from ytmdl.exceptions import DownloadError, ConvertError, NoMetaError
from ytmdl.__version__ import __version__

# init colorama for windows
init()

LOGGER_OUTTEMPLATE = " %a{}==>{}%".format(Style.BRIGHT, Style.RESET_ALL)
LOGGER_FILEFORMAT = "[{logger}]:[{time}]: "
logger = Logger('ytmdl',
                log_path=path.join(xdg_cache_home,'ytmdl/logs/log.cat'),
                format=LOGGER_OUTTEMPLATE,
                file_format=LOGGER_FILEFORMAT,
                update_all=True
)


def arguments():
    """Parse the arguments."""
    parser = argparse.ArgumentParser()

    parser.add_argument('SONG_NAME', help="Name of the song to download.\
                         Can be an URL to a playlist as well. It will be\
                         automatically recognized.",
                        type=str, nargs="*")
    parser.add_argument('-q', '--quiet',
                        help="Don't ask the user to select songs\
                        if more than one search result.\
                        The first result in each case will be considered.",
                        action='store_true')
    metadata_group = parser.add_argument_group("Metadata")
    metadata_group.add_argument(
                        '--song', help="The song to search in Metadata. \
                        Particularly useful for songs that have the names in a\
                        different language in YouTube. For Example, greek songs.",
                        metavar='SONG-METADATA', default=None)
    metadata_group.add_argument(
                        '--choice', help="The choice that the user wants\
                        to go for. Usefull to pass along with --quiet.\
                        Choices start at 1", choices=range(1,50),
                        type=int, default=None, metavar="CHOICE")
    metadata_group.add_argument(
                        '--artist', help="The name of the song's artist.\
                        Pass it with a song name.")
    metadata_group.add_argument(
                        '--album', help="The name of the song's album.\
                        Pass it with a song name.")
    metadata_group.add_argument('--disable-metaadd', help="Disable addition of\
                        passed artist and album keyword to the youtube search\
                        in order to get a more accurate result. (Default: false)",
                        action="store_true")
    metadata_group.add_argument('--skip-meta', help="Skip setting the metadata and\
                        just copy the converted song to the destination directory.\
                        '--manual-meta' will override this option, pass only one\
                        of them.",
                        action="store_true")
    metadata_group.add_argument('-m', '--manual-meta', help="Manually enter song\
                        details.", action="store_true")

    parser.add_argument('--proxy', help='Use the specified HTTP/HTTPS/SOCKS proxy. To enable '
                        'SOCKS proxy, specify a proper scheme. For example '
                        'socks5://127.0.0.1:1080/. Pass in an empty string (--proxy "") '
                        'for direct connection', default=None, metavar='URL')
    parser.add_argument('--url',
                        help="Youtube song link.")
    parser.add_argument('--list', help="Download list of songs.\
                        The list should have one song name in every line.",
                        default=None, metavar="path to list".upper())
    parser.add_argument('--nolocal',
                        help='Don\'t search locally for the song before\
                        downloading.',
                        action='store_true')
    parser.add_argument('--format',
                        help="The format in which the song should be downloaded.\
                        Default is mp3, but can be set in config. Available options are\
                         {}".format(defaults.DEFAULT.VALID_FORMATS), 
                        default=defaults.DEFAULT.DEFAULT_FORMAT,
                        type=str)
    parser.add_argument('--trim', '-t', help="Trim out the audio from the song. Use \
                        underlying speech and music segmentation engine to determine \
                        and keep only the music in the file. Useful in songs where there \
                        are speeches, noise etc before/after the start of the song. Default \
                        is false.", action='store_true')
    parser.add_argument('--version', action='version', version=__version__,
                        help='show the program version number and exit')
    parser.add_argument('--get-opts', action="store_true", help=argparse.SUPPRESS)

    playlist_group = parser.add_argument_group("Playlist")
    playlist_group.add_argument(
        "--pl-start",
        help="Playlist video to start at (default is 1)",
        default=None,
        metavar="NUMBER",
        type=int
    )
    playlist_group.add_argument(
        "--pl-end",
        help="Playlist video to end at (default is last)",
        default=None,
        metavar="NUMBER",
        type=int
    )
    playlist_group.add_argument(
        "--pl-items",
        help="Playlist video items to download. \
             Specify indices of the videos present in the\
             playlist seperated by commas like: '--playlist-items\
              1, 2, 4, 6' if you want to download videos indexed\
             1, 2, 4 and 6. Range can also be passed like:\
             '--playlist-items 1-3, 5-7' to download the videos\
             indexed at 1, 2, 3, 5, 6, 7.",
        type=str,
        metavar="item_spec".upper(),
        default=None
    )
    playlist_group.add_argument(
        "--ignore-errors",
        help="Ignore if downloading any video fails in a playlist.\
             If passed, the execution will move to the next video in the\
             passed playlist.",
        action="store_true"
    )
    playlist_group.add_argument(
        "--title-as-name",
        help="Use the title of the video as the name of the song to search\
            for metadata. If not passed, user will be asked if they\
            want to use a different name and continue accordingly.",
        action="store_true"
    )
    
    logger_group = parser.add_argument_group("Logger")
    logger_group.add_argument(
        "--level",
        help="The level of the logger that will be used while verbosing.\
            Use `--list-level` to check available options." + "\n",
        default="INFO",
        type=str
    )
    logger_group.add_argument(
        "--disable-file",
        help="Disable logging to files",
        default=False,
        action="store_true",
    )
    logger_group.add_argument(
        "--list-level",
        help="List all the available logger levels.",
        action="store_true"
    )

    args = parser.parse_args()

    return args


def main(args):
    """Run on program call."""

    if args.list_level:
        logger.list_available_levels()
        exit(0)

    # Update the logger flags, in case those are not the default ones.
    if args.level.lower != "info":
        logger.update_level(args.level.upper())

    if args.disable_file:
        logger.update_disable_file(True)
        logger.debug("Writing logs to file disabled")

    # Just a message to make the user aware of the current running state
    logger.debug("Logger running in DEBUG mode")
    logger.debug("Passed args: {}".format(args))

    # Check if --setup is passed
    if not setupConfig.check_config_setup():
        logger.debug("Config not present, creating default.")
        setupConfig.make_config()
        logger.debug("Config created")
        logger.info("Created new config since none was present")

    if not args.SONG_NAME and not args.url:
        logger.critical("Song Name is required. Check 'ytmdl --help' for help.")

    logger.debug(args.SONG_NAME)
    if len(args.SONG_NAME) > 1:
        song_name = ' '.join(args.SONG_NAME)
    elif not args.SONG_NAME:

        try:
            # Fetch the title of the song
            song_name = yt.get_title(args.url)
            logger.debug(song_name)
            logger.hold()
        except ExtractorError:
            if args.ignore_errors:
                return

            # If ignore was not passed exit
            logger.critical("Wasn't able to extract song data.",
                            "Use `--ignore-errors` to ignore this error")

        # Ask the user if they want to go with the extracted
        # title or if they would like to change it.
        if not args.title_as_name:
            song_name = utility.get_new_title(song_name)
    else:
        song_name = args.SONG_NAME[0]

    logger.debug(song_name)
    logger.hold()

    if not args.nolocal:
        # Search for the song locally
        if not cache.main(song_name):
            return 0

    # Check if ffmpeg is installed.
    if not utility.is_present('ffmpeg'):
        logger.critical("ffmpeg is not installed. Please install it!")

    # Check if youtube-dl is installed.
    if not utility.is_present('youtube-dl'):
        logger.critical("youtube-dl is not installed. Please install it!")

    is_quiet = args.quiet
    passed_format = args.format.lower()

    logger.debug("proxy passed: {}".format(args.proxy))
    logger.debug("Passed format: {}".format(passed_format))

    # Check if passed format is support, if not exit.
    if passed_format not in defaults.DEFAULT.VALID_FORMATS:
        logger.critical("Passed format is not supported yet!")

    if args.song is not None:
        song_metadata = args.song
    else:
        song_metadata = song_name


    link, yt_title = search(song_name=song_name, args=args)

    # Try to download the song
    # TODO: Change the way ignore-errors is used in order to handle playlists
    try:
        path = download(link, yt_title, args)
    except DownloadError as dw_error:
        if args.ignore_errors:
            logger.info("--ignore-errors passed. Skipping this song!")
            return

        logger.critical("ERROR: {}".format(dw_error))
        return


    # Try to convert the song
    try:
        conv_name = convert(path, passed_format)
    except ConvertError as convert_error:
        logger.critical('ERROR: {}'.format(convert_error))
        return

    # Trim the song
    trim(conv_name, args)

    logger.debug("Skip Meta: {}".format(args.skip_meta))

    if args.skip_meta:
        # Do a dry cleanup
        if dir.dry_cleanup(conv_name, song_name):
            logger.info("Done")
            return

    # Else fill the meta by searching
    try:
        track_selected = meta(conv_name, song_name, song_metadata, args)
    except NoMetaError:
        logger.critical(str(NoMetaError))
        return

    if dir.cleanup([track_selected], 0, passed_format):
        logger.info("Done")


def search(song_name, args) -> Union[str, str]:
    """Search the song on YouTube, ask the user for an input and accordingly
    return a selected song.

    The song can be extracted either from an URL or the name. If the name is
    present, we will search on YouTube for the name, ask the user for a choice
    and accordingly return the choice.

    If the URL is present, we will extract the data from the URL and return it
    accordingly.
    """
    # Declare some default values
    YOUTUBE_LINK_BASE = "https://youtube.com{}"
    PASSED_CHOICE = args.choice
    URL = args.url
    IS_QUIET = args.quiet

    if URL is None:
        if IS_QUIET:
            logger.info('Quiet is enabled')

        logger.info('Searching Youtube for {}{}{}'.format(
                Fore.LIGHTYELLOW_EX,
                song_name,
                Style.RESET_ALL
        ))

        data = yt.search(song_name, not args.disable_metaadd,
                                args.proxy,
                                kw=[args.artist, args.album])
        
        # Handle the exception if urls has len 0
        if len(data) == 0:
            logger.critical("No song found. Please try again with a different keyword.")

        if not IS_QUIET:
            # Ask for a choice
            choice = song.getChoice(data, 'mp3')
        elif PASSED_CHOICE is not None and PASSED_CHOICE <= len(data):
            choice = PASSED_CHOICE - 1
            logger.info("Using {} as choice".format(PASSED_CHOICE))
        else:
            choice = 0

        return YOUTUBE_LINK_BASE.format(data[choice]["href"]), data[choice]["title"]

    # If the url is passed then get the data
    data = []

    # Strip unwanted stuff from the URL
    URL = stringutils.srtip_unwanted_words_from_url(URL)

    # Get video data from youtube
    temp_data = yt.scan_video(yt.get_href(URL), args.proxy)

    # Sometimes the temp_data may be returned as unauthorized, skip that
    if type(temp_data) is str and temp_data.lower() == "Unauthorized".lower():
        if args.ignore_errors:
            logger.warning("{}: is unauthorized".format(URL))
            return
        else:
            logger.critical("{}: is unauthorized".format(URL))

    data.append(temp_data)

    # In this case choice will be 0
    return URL, data[0]["title"]


def download(link, yt_title, args) -> str:
    """Download the song by using the passed link.
    
    The song will be saved with the passed title.
    Return the saved path of the song.
    """
    logger.info('Downloading {}{}{} in {}{}kbps{}'.format(
        Fore.LIGHTMAGENTA_EX,
        yt_title,
        Style.RESET_ALL,
        Fore.LIGHTYELLOW_EX,
        defaults.DEFAULT.SONG_QUALITY,
        Style.RESET_ALL
    ))
    path = yt.dw(link, args.proxy, yt_title, args.format)

    if type(path) is not str:
        # Probably an error occured
        raise DownloadError(link, path)

    logger.info('Downloaded!')
    return path


def convert(path: str, passed_format: str) -> str:
    """Conver the song into the proper format as asked by
    the user.
    """
    FORMAT_CONVERSION_MAP = {
        "mp3": utility.convert_to_mp3,
        "opus": utility.convert_to_opus
    }

    # If it is m4a, don't convert
    if passed_format == "m4a":
        return path

    # Else the format needs to be in the list
    # It should probably in the list since the check
    # is done once before by the main function
    if passed_format not in FORMAT_CONVERSION_MAP.keys():
        return

    conv_name = FORMAT_CONVERSION_MAP.get(passed_format)(path)

    if type(conv_name) is not str:
        raise ConvertError(conv_name)

    return conv_name


def trim(name: str, args) -> None:
    """Trim the song of unwanted noise by making calls to the
    internal functions.
    """
    # Check if we need to import trim. Importing it is realy inefficient if
    # the user is not going to use it.
    if not args.trim:
        return

    logger.debug("Need to trim the song, importing the trim module.")
    try:
        from ytmdl import trim
    except ImportError:
        logger.error("Dependencies needed for trim are not installed. Please use the"
                     " [noise-clean] specifier when installing ytmdl. The script will"
                     " continue without trimming.")
        return

    # Trim the song if the trim option is passed.
    logger.info("Passing the song to get trimmed.")
    trim.Trim(name)


def meta(conv_name: str, song_name: str, search_by: str, args):
    """Handle adding the metadata for the passed song.
    
    We will use the passed name to search for metadata, ask
    the user for a choice and accordingly add the meta to
    the song.
    """
    PASSED_FORMAT = args.format
    IS_QUIET = args.quiet

    if args.manual_meta:
        # Read the values from the user.
        TRACK_INFO = manual.get_data(song_name)

        # Since above code will return a list with just
        # one element, the option will be set to 0 by
        # default and won't ask the user
    else:
        # Else add metadata in ordinary way
        logger.info('Getting song data for {}...'.format(search_by))
        TRACK_INFO = metadata.SEARCH_SONG(search_by, filters=[args.artist, args.album])

    # If no meta was found raise error
    if not TRACK_INFO:
        raise NoMetaError(search_by)

    logger.info('Setting data...')
    option = song.setData(TRACK_INFO, IS_QUIET, conv_name, PASSED_FORMAT, args.choice)

    if type(option) is not int:
        # TODO: Raise exception
        logger.critical('ERROR: {}'.format(option))

    return TRACK_INFO[option]


def extract_data():
    """Extract the arguments and act accordingly."""
    args = arguments()

    # If options is asked for
    if args.get_opts:
        print(" ".join(("--{}".format(opt.replace("_", "-")) for opt in vars(args))))
        return

    if args.list is not None:
        songs = utility.get_songs(args.list)
        logger.debug(str(songs))
        if len(songs) != 0:
            logger.info("Downloading songs in {}".format(args.list))
            for song_name in songs:
                logger.debug(song_name)
                args.SONG_NAME = [song_name]
                main(args)
        else:
            logger.info("{}: is empty".format(args.list))
    elif args.SONG_NAME and yt.is_playlist(args.SONG_NAME[0]):
        logger.info("Youtube playlist passed...extracting!")
        songs, playlist_name = yt.get_playlist(
                                    args.SONG_NAME[0],
                                    args.proxy,
                                    args.pl_start,
                                    args.pl_end,
                                    args.pl_items
                                )

        # Check if data is actually returned
        if songs is None:
            logger.error("Couldn't extract playlist data!")

        logger.info("Playlist: {}".format(playlist_name))
        logger.info("{} songs found".format(len(songs)))

        # Before passing the args, make the song name None
        # so that the song name will be extracted in main
        args.SONG_NAME = []

        # Iterate and work on the data.
        url_base = "https://www.youtube.com/watch?v="
        for song in songs:
            args.url = url_base + song["url"]
            main(args)
    else:
        main(args)


if __name__ == '__main__':
    try:
        extract_data()
    except KeyboardInterrupt:
        logger.info("\nExiting..!")
